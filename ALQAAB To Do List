

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALQAAB Task Manager</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚úÖ</text></svg>">
    
    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('./sw.js')
                    .then(function(registration) {
                        console.log('SW registered: ', registration);
                    })
                    .catch(function(registrationError) {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }
    </script>

    <style>
        /* All previous CSS styles remain exactly the same except calendar related styles removed */
        :root {
            --primary-color: #4361ee;
            --primary-light: #4895ef;
            --secondary-color: #3f37c9;
            --success-color: #4cc9f0;
            --danger-color: #f72585;
            --warning-color: #f8961e;
            --light-bg: #f8f9fa;
            --dark-bg: #212529;
            --light-text: #f8f9fa;
            --dark-text: #212529;
            --card-bg: #ffffff;
            --shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
            --border-color: #e0e0e0;
            --completed-hover-bg: #e9ecef;
            --footer-bg: linear-gradient(135deg, #2d3748, #4a5568);
            --footer-text: #e2e8f0;
        }

        .dark-mode {
            --light-bg: #121212;
            --dark-bg: #f8f9fa;
            --light-text: #212529;
            --dark-text: #f8f9fa;
            --card-bg: #1e1e1e;
            --shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            --border-color: #333333;
            --completed-hover-bg: #2d2d2d;
            --footer-bg: linear-gradient(135deg, #0f172a, #1e293b);
            --footer-text: #cbd5e1;
        }

        /* Initial hidden state to prevent flash */
        body:not(.loaded) {
            opacity: 0;
            transition: none !important;
        }

        body.loaded {
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--light-bg);
            color: var(--dark-text);
            transition: var(--transition);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            flex: 1;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 1rem 0;
            box-shadow: var(--shadow);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .app-title {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .theme-toggle {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 25px;
            padding: 8px 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            font-size: 0.9rem;
            transition: var(--transition);
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Search Bar */
        .search-section {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 15px 20px;
            margin: 20px 0;
            box-shadow: var(--shadow);
        }

        .search-container {
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 12px 45px 12px 15px;
            border: 1px solid var(--border-color);
            border-radius: 25px;
            background-color: var(--card-bg);
            color: var(--dark-text);
            font-size: 1rem;
            transition: var(--transition);
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.2);
        }

        .search-icon {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.2rem;
            color: var(--dark-text);
            opacity: 0.7;
        }

        /* Projects Section */
        .projects-section {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: var(--shadow);
        }

        .projects-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .projects-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .project-input {
            flex: 1;
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background-color: var(--card-bg);
            color: var(--dark-text);
            transition: var(--transition);
        }

        .project-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.2);
        }

        .projects-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .project-item {
            padding: 8px 15px;
            background-color: var(--primary-color);
            color: white;
            border-radius: 20px;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
        }

        .project-item:hover {
            background-color: var(--secondary-color);
        }

        .project-item.active {
            background-color: var(--warning-color);
            box-shadow: 0 0 0 2px var(--warning-color);
        }

        .project-item .delete-project {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 0.8rem;
            opacity: 0.7;
            padding: 2px 5px;
            border-radius: 50%;
        }

        .project-item .delete-project:hover {
            opacity: 1;
            background-color: rgba(255, 255, 255, 0.2);
        }

        /* Task Input Section */
        .task-input-section {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: var(--shadow);
        }

        .task-input-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: end;
        }

        .form-group {
            flex: 1;
            min-width: 200px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .form-control {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background-color: var(--card-bg);
            color: var(--dark-text);
            transition: var(--transition);
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.2);
        }

        /* Controls Section */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
            align-items: center;
        }

        .filter-tabs {
            display: flex;
            gap: 5px;
            background-color: var(--card-bg);
            border-radius: 25px;
            padding: 5px;
            box-shadow: var(--shadow);
        }

        .filter-tab {
            padding: 8px 15px;
            border: none;
            background: transparent;
            border-radius: 20px;
            cursor: pointer;
            transition: var(--transition);
            color: var(--dark-text);
            font-weight: 500;
        }

        .filter-tab.active {
            background-color: var(--primary-color);
            color: white;
        }

        .sort-select {
            padding: 8px 15px;
            border: 1px solid var(--border-color);
            border-radius: 25px;
            background-color: var(--card-bg);
            color: var(--dark-text);
            cursor: pointer;
            transition: var(--transition);
        }

        .sort-select:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        /* Tags Filter - Updated with delete button */
        .tags-filter {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 10px 0;
        }

        .tag-filter {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            border-radius: 15px;
            background-color: var(--card-bg);
            color: var(--dark-text);
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .tag-filter.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .tag-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            flex-shrink: 0;
        }

        .delete-tag {
            background: none;
            border: none;
            color: inherit;
            cursor: pointer;
            font-size: 0.7rem;
            opacity: 0.7;
            padding: 1px 3px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .delete-tag:hover {
            opacity: 1;
            background-color: rgba(0, 0, 0, 0.1);
        }

        .dark-mode .delete-tag:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Task List - Card Style */
        .tasks-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .task-card {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: var(--shadow);
            transition: var(--transition);
            border-left: 4px solid var(--primary-color);
            overflow: hidden;
            position: relative;
        }

        .task-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .task-card.completed {
            opacity: 0.8;
            border-left-color: var(--success-color);
            background: linear-gradient(135deg, #dfeffd, #bde9fd);
            border: 1px solid #b3e5fc;
        }

        .dark-mode .task-card.completed {
            background: linear-gradient(135deg, #1a3c5a, #2a4d6e);
            border: 1px solid #3a5d7e;
            opacity: 0.9;
        }

        .task-card.completed:hover {
            background-color: var(--completed-hover-bg);
        }

        .task-card.completed .task-title {
            text-decoration: line-through;
        }

        .task-card.high {
            border-left-color: var(--danger-color);
        }

        .task-card.medium {
            border-left-color: var(--warning-color);
        }

        .task-card.low {
            border-left-color: var(--success-color);
        }

        .task-card.pinned {
            border: 2px solid var(--warning-color);
            background: linear-gradient(135deg, #fff9e6, #fff3d1);
        }

        .dark-mode .task-card.pinned {
            background: linear-gradient(135deg, #3a2e0a, #4a3e1a);
            border: 2px solid var(--warning-color);
        }

        .task-card.overdue {
            border: 2px solid var(--danger-color);
            background: linear-gradient(135deg, #ffe6e6, #ffd1d1);
        }

        .dark-mode .task-card.overdue {
            background: linear-gradient(135deg, #5a1a1a, #6e2a2a);
            border: 2px solid var(--danger-color);
        }

        .task-card.due-soon {
            border: 2px solid var(--warning-color);
            background: linear-gradient(135deg, #fff3e6, #ffe8d1);
        }

        .dark-mode .task-card.due-soon {
            background: linear-gradient(135deg, #5a3e1a, #6e4e2a);
            border: 2px solid var(--warning-color);
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
            gap: 10px;
        }

        /* Editable Task Title */
        .task-title {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 5px;
            word-break: break-word;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            line-clamp: 3;
            display: box;
            box-orient: vertical;
            flex: 1;
            min-width: 0;
            cursor: text;
            padding: 4px 8px;
            border-radius: 4px;
            transition: var(--transition);
        }

        .task-title:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .dark-mode .task-title:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .task-title.editing {
            background-color: var(--light-bg);
            border: 1px solid var(--primary-color);
            outline: none;
            -webkit-line-clamp: unset;
            line-clamp: unset;
        }

        .dark-mode .task-title.editing {
            background-color: var(--dark-bg);
        }

        /* Link styles in task titles */
        .task-title a {
            color: var(--primary-color);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: var(--transition);
            word-break: break-all;
        }

        .task-title a:hover {
            border-bottom-color: var(--primary-color);
        }

        .dark-mode .task-title a {
            color: var(--primary-light);
        }

        .task-priority {
            padding: 3px 8px;
            border-radius: 12px;
            font-weight: 500;
            text-align: center;
            font-size: 0.75rem;
            flex-shrink: 0;
        }

        .task-priority.high {
            background-color: rgba(247, 37, 133, 0.1);
            color: var(--danger-color);
        }

        .task-priority.medium {
            background-color: rgba(248, 150, 30, 0.1);
            color: var(--warning-color);
        }

        .task-priority.low {
            background-color: rgba(76, 201, 240, 0.1);
            color: var(--success-color);
        }

        .task-meta {
            font-size: 0.8rem;
            color: var(--dark-text);
            opacity: 0.7;
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .task-date {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .task-project {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            max-width: fit-content;
        }

        .task-due-date {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .task-due-date.overdue {
            color: var(--danger-color);
            font-weight: 600;
        }

        .task-due-date.due-soon {
            color: var(--warning-color);
            font-weight: 600;
        }

        .task-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }

        .task-tag {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .tag-color-small {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }

        /* Pin Button Styles */
        .pin-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            transition: var(--transition);
            opacity: 0.7;
            z-index: 2;
        }

        .pin-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .pin-btn.pinned {
            opacity: 1;
            color: var(--warning-color);
        }

        /* Separator between pinned and unpinned tasks */
        .pinned-separator {
            grid-column: 1 / -1;
            text-align: center;
            margin: 20px 0;
            position: relative;
        }

        .pinned-separator hr {
            border: none;
            height: 1px;
            background-color: var(--border-color);
            margin: 10px 0;
        }

        .pinned-separator-text {
            display: inline-block;
            background-color: var(--card-bg);
            padding: 0 15px;
            color: var(--dark-text);
            opacity: 0.7;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .subtasks-section {
            margin-top: 15px;
        }

        .subtasks-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .subtasks-list {
            margin-bottom: 10px;
        }

        .subtask-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .subtask-item:last-child {
            border-bottom: none;
        }

        .subtask-item.completed .subtask-title {
            text-decoration: line-through;
            opacity: 0.7;
        }

        .subtask-checkbox {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }

        /* Editable Subtask Title */
        .subtask-title {
            flex: 1;
            font-size: 0.9rem;
            word-break: break-word;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-clamp: 2;
            display: box;
            box-orient: vertical;
            min-width: 0;
            cursor: text;
            padding: 2px 6px;
            border-radius: 3px;
            transition: var(--transition);
        }

        .subtask-title:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .dark-mode .subtask-title:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .subtask-title.editing {
            background-color: var(--light-bg);
            border: 1px solid var(--primary-color);
            outline: none;
            -webkit-line-clamp: unset;
            line-clamp: unset;
        }

        .dark-mode .subtask-title.editing {
            background-color: var(--dark-bg);
        }

        /* Link styles in subtask titles */
        .subtask-title a {
            color: var(--primary-color);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: var(--transition);
            word-break: break-all;
        }

        .subtask-title a:hover {
            border-bottom-color: var(--primary-color);
        }

        .dark-mode .subtask-title a {
            color: var(--primary-light);
        }

        .delete-subtask {
            background: none;
            border: none;
            color: var(--danger-color);
            cursor: pointer;
            font-size: 0.8rem;
            padding: 2px 5px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .delete-subtask:hover {
            background-color: rgba(247, 37, 133, 0.1);
        }

        .add-subtask-form {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .add-subtask-input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--card-bg);
            color: var(--dark-text);
            font-size: 0.9rem;
        }

        .add-subtask-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        /* Deleted Subtasks Section */
        .deleted-subtasks-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px dashed var(--border-color);
        }

        .deleted-subtasks-title {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--dark-text);
            opacity: 0.7;
        }

        .deleted-subtasks-list {
            margin-bottom: 10px;
            max-height: 120px;
            overflow-y: auto;
        }

        .deleted-subtask-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 0;
            border-bottom: 1px solid var(--border-color);
            opacity: 0.7;
        }

        .deleted-subtask-item:last-child {
            border-bottom: none;
        }

        /* Deleted subtask title with line clamping - FIXED VERSION */
        .deleted-subtask-title {
            flex: 1;
            font-size: 0.85rem;
            word-break: break-word;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-clamp: 2;
            display: box;
            box-orient: vertical;
            text-decoration: line-through;
        }

        .restore-subtask {
            background: none;
            border: none;
            color: var(--success-color);
            cursor: pointer;
            font-size: 0.75rem;
            padding: 2px 5px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .restore-subtask:hover {
            background-color: rgba(76, 201, 240, 0.1);
        }

        .task-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .task-action {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .task-action.primary {
            background-color: var(--primary-color);
            color: white;
        }

        .task-action.success {
            background-color: var(--success-color);
            color: white;
        }

        .task-action.danger {
            background-color: var(--danger-color);
            color: white;
        }

        .task-action.warning {
            background-color: var(--warning-color);
            color: white;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--dark-text);
            opacity: 0.7;
            grid-column: 1 / -1;
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        /* Footer - UPDATED DESIGN */
        footer {
            background: var(--footer-bg);
            color: var(--footer-text);
            padding: 30px 0 20px;
            margin-top: 50px;
            border-top: 3px solid var(--primary-color);
            position: relative;
            overflow: hidden;
        }

        footer::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary-color), var(--success-color), var(--warning-color));
        }

        .footer-content {
            font-size: 0.9rem;
            opacity: 0.9;
            text-align: center;
            line-height: 1.6;
        }

        .footer-content p {
            margin-bottom: 8px;
        }

        .footer-content p:last-child {
            margin-bottom: 0;
        }

        .footer-version {
            font-weight: 600;
            color: var(--primary-light);
            font-size: 0.95rem;
        }

        .footer-offline {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            color: #10b981;
            font-weight: 500;
        }

        .footer-copyright {
            opacity: 0.7;
            font-size: 0.85rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 15px;
            margin-top: 15px;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1100;
        }

        .toast {
            background-color: var(--card-bg);
            color: var(--dark-text);
            padding: 15px 20px;
            border-radius: 5px;
            box-shadow: var(--shadow);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: toastSlideIn 0.3s ease;
            max-width: 300px;
        }

        @keyframes toastSlideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .toast.success {
            border-left: 4px solid var(--success-color);
        }

        .toast.error {
            border-left: 4px solid var(--danger-color);
        }

        .toast.warning {
            border-left: 4px solid var(--warning-color);
        }

        .toast.info {
            border-left: 4px solid var(--primary-color);
        }

        /* Buttons */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--secondary-color);
        }

        .btn-success {
            background-color: var(--success-color);
            color: white;
        }

        .btn-danger {
            background-color: var(--danger-color);
            color: white;
        }

        .btn-warning {
            background-color: var(--warning-color);
            color: white;
        }

        /* Settings Section */
        .settings-section {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .settings-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .settings-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }

        .setting-card {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: var(--shadow);
        }

        .setting-title {
            font-size: 1.1rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .setting-description {
            font-size: 0.9rem;
            margin-bottom: 15px;
            opacity: 0.7;
        }

        /* Trash Section */
        .trash-section {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .trash-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .trash-title {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .trash-actions {
            display: flex;
            gap: 10px;
        }

        .trash-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .trash-card {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: var(--shadow);
            transition: var(--transition);
            border-left: 4px solid #6c757d;
            opacity: 0.8;
        }

        .trash-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .trash-actions-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .trash-action {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .task-input-row {
                flex-direction: column;
            }

            .form-group {
                min-width: 100%;
            }

            .tasks-container {
                grid-template-columns: 1fr;
            }

            .settings-options {
                grid-template-columns: 1fr;
            }

            .trash-container {
                grid-template-columns: 1fr;
            }

            .trash-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .trash-actions {
                width: 100%;
            }

            .task-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .task-priority {
                align-self: flex-start;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .projects-controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header>
        <div class="container">
            <div class="header-content">
                <h1 class="app-title">ALQAAB Task Manager</h1>
                <button class="theme-toggle" id="themeToggle">
                    <span>üåô</span> Dark Mode
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <!-- Search Bar -->
        <div class="search-section">
            <div class="search-container">
                <input type="text" class="search-input" id="searchInput" placeholder="Search tasks and subtasks...">
                <div class="search-icon">üîç</div>
            </div>
        </div>

        <!-- Projects Section -->
        <div class="projects-section">
            <h2 class="projects-title">üìÅ Projects</h2>
            <div class="projects-controls">
                <input type="text" id="newProjectInput" placeholder="New project name" class="project-input">
                <button class="btn btn-primary" id="addProjectBtn">+ Add Project</button>
            </div>
            <div class="projects-list" id="projectsList">
                <!-- Projects will be dynamically inserted here -->
            </div>
        </div>

        <!-- Task Input Section -->
        <div class="task-input-section">
            <div class="task-input-row">
                <div class="form-group">
                    <label class="form-label" for="taskTitle">Task Name *</label>
                    <input type="text" class="form-control" id="taskTitle" placeholder="Enter task and press Enter" required>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="taskPriority">Priority</label>
                    <select class="form-control" id="taskPriority">
                        <option value="low">Low</option>
                        <option value="medium" selected>Medium</option>
                        <option value="high">High</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label" for="taskProject">Project</label>
                    <select class="form-control" id="taskProject">
                        <!-- Options will be dynamically populated -->
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label" for="taskDueDate">Due Date</label>
                    <input type="date" class="form-control" id="taskDueDate">
                </div>

                <div class="form-group">
                    <label class="form-label" for="taskTags">Tags</label>
                    <input type="text" class="form-control" id="taskTags" placeholder="work, personal, urgent">
                    <small style="opacity: 0.7; font-size: 0.8rem;">Separate tags with commas</small>
                </div>
                
                <div class="form-group">
                    <label class="form-label">&nbsp;</label>
                    <button class="btn btn-primary" id="addTaskBtn" style="width: 100%;">
                        <span>+</span> Add Task
                    </button>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <div class="filter-tabs">
                <button class="filter-tab active" data-filter="all">All Tasks</button>
                <button class="filter-tab" data-filter="pending">Pending</button>
                <button class="filter-tab" data-filter="completed">Completed</button>
                <button class="filter-tab" data-filter="overdue">Overdue</button>
            </div>

            <select class="sort-select" id="sortSelect">
                <option value="createdAt">Sort by Created Date</option>
                <option value="dueDate">Sort by Due Date</option>
                <option value="priority">Sort by Priority</option>
                <option value="title">Sort by Title</option>
            </select>
        </div>

        <!-- Tags Filter - UPDATED with delete buttons -->
        <div class="tags-filter" id="tagsFilter">
            <!-- Tags will be dynamically inserted here -->
        </div>

        <!-- Tasks Container -->
        <div class="tasks-container" id="tasksList">
            <!-- Tasks will be dynamically inserted here -->
        </div>

        <!-- Empty State -->
        <div class="empty-state" id="emptyState" style="display: none;">
            <div class="empty-state-icon">
                <span>üìã</span>
            </div>
            <h3>No tasks found</h3>
            <p>Get started by creating your first task!</p>
        </div>

        <!-- Trash Section -->
        <div class="trash-section" id="trashSection" style="display: none;">
            <div class="trash-header">
                <h2 class="trash-title">üóëÔ∏è Trash</h2>
                <div class="trash-actions">
                    <button class="btn btn-warning" id="restoreAllBtn">
                        <span>‚Ü∂</span> Restore All
                    </button>
                    <button class="btn btn-danger" id="emptyTrashBtn">
                        <span>üóëÔ∏è</span> Empty Trash
                    </button>
                </div>
            </div>
            <div class="trash-container" id="trashList">
                <!-- Deleted tasks will be dynamically inserted here -->
            </div>
            <div class="empty-state" id="emptyTrashState" style="display: none;">
                <div class="empty-state-icon">
                    <span>üóëÔ∏è</span>
                </div>
                <h3>Trash is empty</h3>
                <p>Deleted tasks will appear here</p>
            </div>
        </div>

        <!-- Settings Section -->
        <div class="settings-section">
            <h2 class="settings-title">Settings</h2>
            <div class="settings-options">
                <div class="setting-card">
                    <h3 class="setting-title">Data Management</h3>
                    <p class="setting-description">Export or import your task data as JSON files.</p>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn btn-success" id="exportSettingsBtn" style="flex: 1;">
                            <span>üì•</span> Export
                        </button>
                        <button class="btn btn-warning" id="importSettingsBtn" style="flex: 1;">
                            <span>üì§</span> Import
                        </button>
                    </div>
                </div>
                <div class="setting-card">
                    <h3 class="setting-title">Text Report</h3>
                    <p class="setting-description">Generate a TEXT report of your current tasks.</p>
                    <button class="btn btn-primary" id="generateTextReportBtn" style="width: 100%;">
                        <span>üìÑ</span> Generate TEXT
                    </button>
                </div>
                <div class="setting-card">
                    <h3 class="setting-title">Appearance</h3>
                    <p class="setting-description">Toggle between light and dark mode.</p>
                    <button class="btn btn-primary" id="themeSettingsBtn" style="width: 100%;">
                        <span>üåô</span> Toggle Theme
                    </button>
                </div>
                <div class="setting-card">
                    <h3 class="setting-title">Danger Zone</h3>
                    <p class="setting-description">Permanently delete all data. This action cannot be undone.</p>
                    <button class="btn btn-danger" id="clearSettingsBtn" style="width: 100%;">
                        <span>üóëÔ∏è</span> Clear All Data
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer - UPDATED DESIGN -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <p class="footer-version">ALQAAB Task Manager v.2.1 (Nov 27, 2025)</p>
                <p class="footer-offline">
                    <span>üåê</span> Works offline ‚Äì Data saved in your browser
                </p>
                <p class="footer-copyright">
                    ¬© 2025 ALQAAB Org. Developed by ALQAAB Web Studio | Shahbaz Ali.
                </p>
            </div>
        </div>
    </footer>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Import File Input (Hidden) -->
    <input type="file" id="importFileInput" style="display: none;" accept=".json">

    <script>
        // App State
        let tasks = [];
        let trash = [];
        let currentFilter = 'all';
        let currentSort = localStorage.getItem('alqaab-todo-sort') || 'createdAt';
        let currentSearch = '';
        let currentTagFilter = null;
        let tags = JSON.parse(localStorage.getItem('alqaab-todo-tags')) || [
            { name: 'work', color: '#4361ee' },
            { name: 'personal', color: '#4cc9f0' },
            { name: 'home', color: '#f8961e' },
            { name: 'smit', color: '#f72585' },
            { name: 'learning', color: '#3f37c9' },
            { name: 'urgent', color: '#dc2626' }
        ];
        
        // Projects State
        let projects = JSON.parse(localStorage.getItem('alqaab-todo-projects')) || [
            { id: 'default', name: 'All Tasks', color: '#4361ee' },
            { id: 'personal', name: 'Personal', color: '#4cc9f0' },
            { id: 'work', name: 'Work', color: '#f8961e' }
        ];
        let currentProject = 'default';

        // IndexedDB setup for persistent storage
        const DB_NAME = 'ALQAABTodoDB';
        const DB_VERSION = 1;
        const STORE_TASKS = 'tasks';
        const STORE_TRASH = 'trash';
        
        let dbInstance = null;
        let dbOpenRequest = null;

        // DOM Elements
        const tasksList = document.getElementById('tasksList');
        const emptyState = document.getElementById('emptyState');
        const trashSection = document.getElementById('trashSection');
        const trashList = document.getElementById('trashList');
        const emptyTrashState = document.getElementById('emptyTrashState');
        const themeToggle = document.getElementById('themeToggle');
        const filterTabs = document.querySelectorAll('.filter-tab');
        const sortSelect = document.getElementById('sortSelect');
        const searchInput = document.getElementById('searchInput');
        const tagsFilter = document.getElementById('tagsFilter');
        const addTaskBtn = document.getElementById('addTaskBtn');
        const taskTitleInput = document.getElementById('taskTitle');
        const taskPrioritySelect = document.getElementById('taskPriority');
        const taskProjectSelect = document.getElementById('taskProject');
        const taskDueDateInput = document.getElementById('taskDueDate');
        const taskTagsInput = document.getElementById('taskTags');
        const generateTextReportBtn = document.getElementById('generateTextReportBtn');
        const exportSettingsBtn = document.getElementById('exportSettingsBtn');
        const importSettingsBtn = document.getElementById('importSettingsBtn');
        const themeSettingsBtn = document.getElementById('themeSettingsBtn');
        const clearSettingsBtn = document.getElementById('clearSettingsBtn');
        const importFileInput = document.getElementById('importFileInput');
        const restoreAllBtn = document.getElementById('restoreAllBtn');
        const emptyTrashBtn = document.getElementById('emptyTrashBtn');
        
        // Projects Elements
        const addProjectBtn = document.getElementById('addProjectBtn');
        const newProjectInput = document.getElementById('newProjectInput');
        const projectsList = document.getElementById('projectsList');

        // Initialize the app
        async function init() {
            // Apply theme immediately to prevent flash
            applyInitialTheme();
            
            await loadData();
            setupEventListeners();
            renderProjects();
            renderTagsFilter();
            populateProjectDropdown();
            renderTasks();
            renderTrash();
            
            // Mark body as loaded to trigger fade-in
            setTimeout(() => {
                document.body.classList.add('loaded');
            }, 50);
        }

        // Apply theme immediately on page load
        function applyInitialTheme() {
            const savedTheme = localStorage.getItem('alqaab-todo-theme');
            if (savedTheme === 'dark') {
                document.documentElement.classList.add('dark-mode');
                themeToggle.innerHTML = '<span>‚òÄÔ∏è</span> Light Mode';
            }
        }

        // IndexedDB initialization
        async function initDB() {
            if (dbInstance) return dbInstance;
            if (dbOpenRequest) return new Promise((resolve, reject) => {
                dbOpenRequest.onsuccess = () => resolve(dbOpenRequest.result);
                dbOpenRequest.onerror = () => reject(dbOpenRequest.error);
            });

            return new Promise((resolve, reject) => {
                dbOpenRequest = indexedDB.open(DB_NAME, DB_VERSION);
                
                dbOpenRequest.onerror = () => {
                    console.error('IndexedDB error:', dbOpenRequest.error);
                    reject(dbOpenRequest.error);
                };
                
                dbOpenRequest.onsuccess = () => {
                    dbInstance = dbOpenRequest.result;
                    resolve(dbInstance);
                };
                
                dbOpenRequest.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_TASKS)) {
                        db.createObjectStore(STORE_TASKS, { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains(STORE_TRASH)) {
                        db.createObjectStore(STORE_TRASH, { keyPath: 'id' });
                    }
                };
            });
        }

        // Save data to IndexedDB
        async function saveData() {
            try {
                const db = await initDB();
                
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_TASKS, STORE_TRASH], 'readwrite');
                    
                    transaction.oncomplete = () => {
                        localStorage.setItem('alqaab-todo-tasks', JSON.stringify(tasks));
                        localStorage.setItem('alqaab-todo-trash', JSON.stringify(trash));
                        localStorage.setItem('alqaab-todo-tags', JSON.stringify(tags));
                        localStorage.setItem('alqaab-todo-projects', JSON.stringify(projects));
                        resolve();
                    };
                    
                    transaction.onerror = () => {
                        console.error('Transaction error:', transaction.error);
                        reject(transaction.error);
                    };
                    
                    const tasksStore = transaction.objectStore(STORE_TASKS);
                    const trashStore = transaction.objectStore(STORE_TRASH);
                    
                    tasksStore.clear();
                    trashStore.clear();
                    
                    for (let i = 0; i < tasks.length; i++) {
                        tasksStore.add(tasks[i]);
                    }
                    
                    for (let i = 0; i < trash.length; i++) {
                        trashStore.add(trash[i]);
                    }
                });
                
            } catch (error) {
                console.error('Error saving to IndexedDB:', error);
                localStorage.setItem('alqaab-todo-tasks', JSON.stringify(tasks));
                localStorage.setItem('alqaab-todo-trash', JSON.stringify(trash));
                localStorage.setItem('alqaab-todo-tags', JSON.stringify(tags));
                localStorage.setItem('alqaab-todo-projects', JSON.stringify(projects));
            }
        }

        // Load data from IndexedDB with localStorage fallback
        async function loadData() {
            try {
                const db = await initDB();
                
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_TASKS, STORE_TRASH], 'readonly');
                    
                    transaction.onerror = () => {
                        console.error('Transaction error:', transaction.error);
                        reject(transaction.error);
                    };
                    
                    const tasksStore = transaction.objectStore(STORE_TASKS);
                    const trashStore = transaction.objectStore(STORE_TRASH);
                    
                    const tasksRequest = tasksStore.getAll();
                    const trashRequest = trashStore.getAll();
                    
                    let tasksLoaded = false;
                    let trashLoaded = false;
                    
                    const checkComplete = () => {
                        if (tasksLoaded && trashLoaded) {
                            const savedTheme = localStorage.getItem('alqaab-todo-theme');
                            if (savedTheme === 'dark') {
                                document.documentElement.classList.add('dark-mode');
                                themeToggle.innerHTML = '<span>‚òÄÔ∏è</span> Light Mode';
                            }
                            resolve();
                        }
                    };
                    
                    tasksRequest.onsuccess = () => {
                        if (tasksRequest.result.length > 0) {
                            tasks = tasksRequest.result;
                            for (let i = 0; i < tasks.length; i++) {
                                if (!tasks[i].deletedSubtasks) {
                                    tasks[i].deletedSubtasks = [];
                                }
                                if (!tasks[i].tags) {
                                    tasks[i].tags = [];
                                }
                                if (!tasks[i].project) {
                                    tasks[i].project = 'default';
                                }
                            }
                        } else {
                            const savedTasks = localStorage.getItem('alqaab-todo-tasks');
                            tasks = savedTasks ? JSON.parse(savedTasks) : getSampleTasks();
                            for (let i = 0; i < tasks.length; i++) {
                                if (!tasks[i].deletedSubtasks) {
                                    tasks[i].deletedSubtasks = [];
                                }
                                if (!tasks[i].tags) {
                                    tasks[i].tags = [];
                                }
                                if (!tasks[i].project) {
                                    tasks[i].project = 'default';
                                }
                            }
                        }
                        tasksLoaded = true;
                        checkComplete();
                    };
                    
                    trashRequest.onsuccess = () => {
                        if (trashRequest.result.length > 0) {
                            trash = trashRequest.result;
                        } else {
                            const savedTrash = localStorage.getItem('alqaab-todo-trash');
                            trash = savedTrash ? JSON.parse(savedTrash) : [];
                        }
                        trashLoaded = true;
                        checkComplete();
                    };
                });
                
            } catch (error) {
                console.error('Error loading from IndexedDB:', error);
                const savedTasks = localStorage.getItem('alqaab-todo-tasks');
                const savedTrash = localStorage.getItem('alqaab-todo-trash');
                const savedTags = localStorage.getItem('alqaab-todo-tags');
                const savedProjects = localStorage.getItem('alqaab-todo-projects');
                
                tasks = savedTasks ? JSON.parse(savedTasks) : getSampleTasks();
                trash = savedTrash ? JSON.parse(savedTrash) : [];
                tags = savedTags ? JSON.parse(savedTags) : tags;
                projects = savedProjects ? JSON.parse(savedProjects) : projects;
                
                for (let i = 0; i < tasks.length; i++) {
                    if (!tasks[i].deletedSubtasks) {
                        tasks[i].deletedSubtasks = [];
                    }
                    if (!tasks[i].tags) {
                        tasks[i].tags = [];
                    }
                    if (!tasks[i].project) {
                        tasks[i].project = 'default';
                    }
                }
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Theme toggle
            const toggleThemeHandler = () => {
                const isDarkMode = document.documentElement.classList.toggle('dark-mode');
                localStorage.setItem('alqaab-todo-theme', isDarkMode ? 'dark' : 'light');
                themeToggle.innerHTML = isDarkMode ? '<span>‚òÄÔ∏è</span> Light Mode' : '<span>üåô</span> Dark Mode';
            };
            
            themeToggle.addEventListener('click', toggleThemeHandler);
            themeSettingsBtn.addEventListener('click', toggleThemeHandler);
            
            // Filter tabs
            for (let i = 0; i < filterTabs.length; i++) {
                filterTabs[i].addEventListener('click', function() {
                    for (let j = 0; j < filterTabs.length; j++) {
                        filterTabs[j].classList.remove('active');
                    }
                    this.classList.add('active');
                    currentFilter = this.dataset.filter;
                    renderTasks();
                });
            }
            
            // Sort
            sortSelect.value = currentSort;
            sortSelect.addEventListener('change', (e) => {
                currentSort = e.target.value;
                localStorage.setItem('alqaab-todo-sort', currentSort);
                renderTasks();
            });
            
            // Search - FIXED: Now searches in both task titles and subtask titles
            searchInput.addEventListener('input', (e) => {
                currentSearch = e.target.value.toLowerCase();
                renderTasks();
            });
            
            // Add task button
            addTaskBtn.addEventListener('click', addTask);
            
            // Add task on Enter key
            taskTitleInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    addTask();
                }
            });
            
            // Action buttons
            generateTextReportBtn.addEventListener('click', generateTextReport);
            exportSettingsBtn.addEventListener('click', exportData);
            importSettingsBtn.addEventListener('click', () => importFileInput.click());
            clearSettingsBtn.addEventListener('click', clearData);
            
            // Trash buttons
            restoreAllBtn.addEventListener('click', restoreAllFromTrash);
            emptyTrashBtn.addEventListener('click', emptyTrash);
            
            // File import
            importFileInput.addEventListener('change', importData);
            
            // Add project button
            addProjectBtn.addEventListener('click', addProject);
            
            // Add project on Enter key
            newProjectInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    addProject();
                }
            });
        }

        // Add a new project
        async function addProject() {
            const projectName = newProjectInput.value.trim();
            if (!projectName) {
                showToast('Project name is required', 'error');
                return;
            }
            
            // Check if project already exists
            const existingProject = projects.find(p => p.name.toLowerCase() === projectName.toLowerCase());
            if (existingProject) {
                showToast('Project already exists', 'error');
                return;
            }
            
            const projectId = generateId();
            const colors = ['#4361ee', '#4cc9f0', '#f8961e', '#f72585', '#3f37c9', '#10b981', '#8b5cf6', '#ec4899', '#f59e0b', '#14b8a6'];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            
            const newProject = {
                id: projectId,
                name: projectName,
                color: randomColor
            };
            
            projects.push(newProject);
            await saveData();
            renderProjects();
            populateProjectDropdown();
            newProjectInput.value = '';
            showToast('Project added successfully', 'success');
        }

        // Render projects list
        function renderProjects() {
            const fragment = document.createDocumentFragment();
            
            for (let i = 0; i < projects.length; i++) {
                const project = projects[i];
                const projectItem = document.createElement('div');
                projectItem.className = `project-item ${currentProject === project.id ? 'active' : ''}`;
                projectItem.style.backgroundColor = project.color;
                projectItem.innerHTML = `
                    <span>${project.name}</span>
                    ${project.id !== 'default' ? '<button class="delete-project" data-project-id="' + project.id + '">√ó</button>' : ''}
                `;
                
                projectItem.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('delete-project')) {
                        currentProject = project.id;
                        renderProjects();
                        renderTasks();
                    }
                });
                
                // Delete button for non-default projects
                if (project.id !== 'default') {
                    const deleteBtn = projectItem.querySelector('.delete-project');
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        deleteProject(project.id);
                    });
                }
                
                fragment.appendChild(projectItem);
            }
            
            projectsList.innerHTML = '';
            projectsList.appendChild(fragment);
        }

        // Delete a project
        async function deleteProject(projectId) {
            if (confirm('Delete this project? Tasks in this project will be moved to "All Tasks".')) {
                // Move tasks to default project
                let movedTasks = 0;
                for (let i = 0; i < tasks.length; i++) {
                    if (tasks[i].project === projectId) {
                        tasks[i].project = 'default';
                        movedTasks++;
                    }
                }
                
                // Remove project from array
                const projectIndex = projects.findIndex(p => p.id === projectId);
                if (projectIndex !== -1) {
                    projects.splice(projectIndex, 1);
                }
                
                // If current project was deleted, switch to default
                if (currentProject === projectId) {
                    currentProject = 'default';
                }
                
                await saveData();
                renderProjects();
                populateProjectDropdown();
                renderTasks();
                showToast(`Project deleted. ${movedTasks} tasks moved to "All Tasks".`, 'success');
            }
        }

        // Populate project dropdown in task input form
        function populateProjectDropdown() {
            const fragment = document.createDocumentFragment();
            
            for (let i = 0; i < projects.length; i++) {
                const project = projects[i];
                const option = document.createElement('option');
                option.value = project.id;
                option.textContent = project.name;
                if (project.id === 'default') {
                    option.selected = true;
                }
                fragment.appendChild(option);
            }
            
            taskProjectSelect.innerHTML = '';
            taskProjectSelect.appendChild(fragment);
        }

        // Render tags filter with delete buttons
        function renderTagsFilter() {
            const fragment = document.createDocumentFragment();
            
            // Clear all tag
            const clearTag = document.createElement('button');
            clearTag.className = `tag-filter ${!currentTagFilter ? 'active' : ''}`;
            clearTag.innerHTML = 'All Tags';
            clearTag.addEventListener('click', () => {
                currentTagFilter = null;
                renderTagsFilter();
                renderTasks();
            });
            fragment.appendChild(clearTag);
            
            // Tag filters with delete buttons
            for (let i = 0; i < tags.length; i++) {
                const tag = tags[i];
                const tagFilter = document.createElement('button');
                tagFilter.className = `tag-filter ${currentTagFilter === tag.name ? 'active' : ''}`;
                tagFilter.innerHTML = `
                    <span class="tag-color" style="background-color: ${tag.color}"></span>
                    ${tag.name}
                    <button class="delete-tag" data-tag-name="${tag.name}">√ó</button>
                `;
                
                // Tag click to filter
                tagFilter.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('delete-tag')) {
                        currentTagFilter = currentTagFilter === tag.name ? null : tag.name;
                        renderTagsFilter();
                        renderTasks();
                    }
                });
                
                // Delete tag button
                const deleteBtn = tagFilter.querySelector('.delete-tag');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteTag(tag.name);
                });
                
                fragment.appendChild(tagFilter);
            }
            
            tagsFilter.innerHTML = '';
            tagsFilter.appendChild(fragment);
        }

        // Delete a tag
        async function deleteTag(tagName) {
            if (confirm(`Delete tag "${tagName}"? This will remove the tag from all tasks.`)) {
                // Remove tag from tags array
                const tagIndex = tags.findIndex(t => t.name === tagName);
                if (tagIndex !== -1) {
                    tags.splice(tagIndex, 1);
                }
                
                // Remove tag from all tasks
                let removedFromTasks = 0;
                for (let i = 0; i < tasks.length; i++) {
                    const tagIndexInTask = tasks[i].tags.indexOf(tagName);
                    if (tagIndexInTask !== -1) {
                        tasks[i].tags.splice(tagIndexInTask, 1);
                        removedFromTasks++;
                    }
                }
                
                // If this tag was currently filtered, reset filter
                if (currentTagFilter === tagName) {
                    currentTagFilter = null;
                }
                
                await saveData();
                renderTagsFilter();
                renderTasks();
                showToast(`Tag "${tagName}" deleted. Removed from ${removedFromTasks} tasks.`, 'success');
            }
        }

        // Add a new task
        async function addTask() {
            const title = taskTitleInput.value.trim();
            const priority = taskPrioritySelect.value;
            const project = taskProjectSelect.value;
            const dueDate = taskDueDateInput.value; // This will be empty string if not selected
            const tagsInput = taskTagsInput.value.trim();
            
            if (!title) {
                showToast('Task title is required', 'error');
                return;
            }
            
            // Process tags
            const taskTags = [];
            if (tagsInput) {
                const tagNames = tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag);
                for (let i = 0; i < tagNames.length; i++) {
                    const tagName = tagNames[i].toLowerCase();
                    let tag = tags.find(t => t.name === tagName);
                    if (!tag) {
                        // Create new tag with random color
                        const colors = ['#4361ee', '#4cc9f0', '#f8961e', '#f72585', '#3f37c9', '#dc2626', '#10b981', '#8b5cf6'];
                        tag = {
                            name: tagName,
                            color: colors[Math.floor(Math.random() * colors.length)]
                        };
                        tags.push(tag);
                    }
                    taskTags.push(tag.name);
                }
            }
            
            const now = new Date();
            const newTask = {
                id: generateId(),
                title: title,
                priority: priority,
                project: project,
                status: 'pending',
                createdAt: now.toISOString(),
                dueDate: dueDate || null, // Store null if dueDate is empty
                tags: taskTags,
                subtasks: [],
                deletedSubtasks: [],
                pinned: false
            };
            
            tasks.push(newTask);
            await saveData();
            renderTagsFilter();
            renderTasks();
            
            // Reset form - clear all fields
            taskTitleInput.value = '';
            taskTagsInput.value = '';
            taskDueDateInput.value = ''; // Clear due date field after adding task
            taskTitleInput.focus();
            
            showToast('Task added successfully', 'success');
        }

        // Toggle task status (complete/incomplete)
        async function toggleTaskStatus(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                task.status = task.status === 'completed' ? 'pending' : 'completed';
                
                if (task.status === 'completed') {
                    for (let i = 0; i < task.subtasks.length; i++) {
                        task.subtasks[i].completed = true;
                    }
                }
                
                await saveData();
                renderTasks();
                showToast(`Task marked as ${task.status}`, 'success');
            }
        }

        // Toggle task pinned status
        async function togglePinTask(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                task.pinned = !task.pinned;
                await saveData();
                renderTasks();
                showToast(`Task ${task.pinned ? 'pinned' : 'unpinned'}`, 'success');
            }
        }

        // Delete task (move to trash)
        async function deleteTask(taskId) {
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex !== -1) {
                const [deletedTask] = tasks.splice(taskIndex, 1);
                deletedTask.deletedAt = new Date().toISOString();
                trash.push(deletedTask);
                await saveData();
                renderTasks();
                renderTrash();
                showToast('Task moved to trash', 'success');
            }
        }

        // Add a subtask
        async function addSubtask(taskId, subtaskTitle) {
            const task = tasks.find(t => t.id === taskId);
            if (task && subtaskTitle.trim()) {
                const newSubtask = {
                    id: generateId(),
                    title: subtaskTitle.trim(),
                    completed: false
                };
                
                task.subtasks.push(newSubtask);
                await saveData();
                renderTasks();
                showToast('Subtask added', 'success');
            }
        }

        // Toggle subtask status
        async function toggleSubtaskStatus(taskId, subtaskId) {
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                const subtask = task.subtasks.find(s => s.id === subtaskId);
                if (subtask) {
                    subtask.completed = !subtask.completed;
                    
                    let allSubtasksCompleted = true;
                    for (let i = 0; i < task.subtasks.length; i++) {
                        if (!task.subtasks[i].completed) {
                            allSubtasksCompleted = false;
                            break;
                        }
                    }
                    
                    if (allSubtasksCompleted && task.subtasks.length > 0) {
                        task.status = 'completed';
                    } else if (task.status === 'completed') {
                        task.status = 'pending';
                    }
                    
                    await saveData();
                    renderTasks();
                }
            }
        }

        // Delete a subtask
        async function deleteSubtask(taskId, subtaskId) {
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                const subtaskIndex = task.subtasks.findIndex(s => s.id === subtaskId);
                if (subtaskIndex !== -1) {
                    const [deletedSubtask] = task.subtasks.splice(subtaskIndex, 1);
                    task.deletedSubtasks.push(deletedSubtask);
                    await saveData();
                    renderTasks();
                    showToast('Subtask moved to deleted items', 'success');
                }
            }
        }

        // Restore a deleted subtask
        async function restoreSubtask(taskId, subtaskId) {
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                const subtaskIndex = task.deletedSubtasks.findIndex(s => s.id === subtaskId);
                if (subtaskIndex !== -1) {
                    const [restoredSubtask] = task.deletedSubtasks.splice(subtaskIndex, 1);
                    task.subtasks.push(restoredSubtask);
                    await saveData();
                    renderTasks();
                    showToast('Subtask restored', 'success');
                }
            }
        }

        // Update task title
        async function updateTaskTitle(taskId, newTitle) {
            const task = tasks.find(t => t.id === taskId);
            if (task && newTitle.trim()) {
                task.title = newTitle.trim();
                await saveData();
                renderTasks();
                showToast('Task title updated', 'success');
            }
        }

        // Update subtask title
        async function updateSubtaskTitle(taskId, subtaskId, newTitle) {
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                const subtask = task.subtasks.find(s => s.id === subtaskId);
                if (subtask && newTitle.trim()) {
                    subtask.title = newTitle.trim();
                    await saveData();
                    renderTasks();
                    showToast('Subtask title updated', 'success');
                }
            }
        }

        // Update task due date
        async function updateTaskDueDate(taskId, newDueDate) {
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                task.dueDate = newDueDate;
                await saveData();
                renderTasks();
                showToast('Due date updated', 'success');
            }
        }

        // Function to convert URLs in text to clickable links
        function makeLinksClickable(text) {
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            return text.replace(urlRegex, function(url) {
                return '<a href="' + url + '" target="_blank" rel="noopener noreferrer">' + url + '</a>';
            });
        }

        // Make element editable
        function makeEditable(element, saveCallback) {
            const originalContent = element.innerHTML;
            
            element.contentEditable = true;
            element.classList.add('editing');
            element.focus();
            
            const selection = window.getSelection();
            const range = document.createRange();
            range.selectNodeContents(element);
            selection.removeAllRanges();
            selection.addRange(range);
            
            const saveEdit = () => {
                element.contentEditable = false;
                element.classList.remove('editing');
                saveCallback(element.innerHTML);
            };
            
            const handleKeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveEdit();
                } else if (e.key === 'Escape') {
                    element.innerHTML = originalContent;
                    element.contentEditable = false;
                    element.classList.remove('editing');
                    element.removeEventListener('keydown', handleKeydown);
                    element.removeEventListener('blur', handleBlur);
                }
            };
            
            const handleBlur = () => {
                saveEdit();
            };
            
            element.addEventListener('keydown', handleKeydown);
            element.addEventListener('blur', handleBlur);
        }

        // Get tasks based on current filters and search - FIXED: Now searches in subtasks too
        function getFilteredTasks() {
            let filteredTasks = [];
            
            for (let i = 0; i < tasks.length; i++) {
                const task = tasks[i];
                
                // Filter by status
                let statusMatch = true;
                if (currentFilter === 'pending' && task.status !== 'pending') {
                    statusMatch = false;
                } else if (currentFilter === 'completed' && task.status !== 'completed') {
                    statusMatch = false;
                } else if (currentFilter === 'overdue') {
                    if (task.status === 'completed' || !task.dueDate) {
                        statusMatch = false;
                    } else {
                        const dueDate = new Date(task.dueDate);
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        statusMatch = dueDate < today;
                    }
                }
                
                // Filter by search - FIXED: Now searches in both task title and subtask titles
                let searchMatch = true;
                if (currentSearch) {
                    const taskTitleMatch = task.title.toLowerCase().includes(currentSearch);
                    const tagsMatch = task.tags.some(tag => tag.toLowerCase().includes(currentSearch));
                    
                    // Check subtasks for search match
                    let subtaskMatch = false;
                    for (let j = 0; j < task.subtasks.length; j++) {
                        if (task.subtasks[j].title.toLowerCase().includes(currentSearch)) {
                            subtaskMatch = true;
                            break;
                        }
                    }
                    
                    searchMatch = taskTitleMatch || tagsMatch || subtaskMatch;
                }
                
                // Filter by tag
                let tagMatch = true;
                if (currentTagFilter) {
                    tagMatch = task.tags.includes(currentTagFilter);
                }
                
                // Filter by project
                let projectMatch = true;
                if (currentProject !== 'default') {
                    projectMatch = task.project === currentProject;
                }
                
                if (statusMatch && searchMatch && tagMatch && projectMatch) {
                    filteredTasks.push(task);
                }
            }
            
            return filteredTasks;
        }

        // Render tasks based on current filter and sort
        function renderTasks() {
            let filteredTasks = getFilteredTasks();
            
            // Separate pinned and unpinned tasks
            const pinnedTasks = filteredTasks.filter(task => task.pinned);
            const unpinnedTasks = filteredTasks.filter(task => !task.pinned);
            
            // Sort tasks
            const sortTasks = (taskArray) => {
                if (currentSort === 'createdAt') {
                    taskArray.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                } else if (currentSort === 'dueDate') {
                    taskArray.sort((a, b) => {
                        if (!a.dueDate && !b.dueDate) return 0;
                        if (!a.dueDate) return 1;
                        if (!b.dueDate) return -1;
                        return new Date(a.dueDate) - new Date(b.dueDate);
                    });
                } else if (currentSort === 'priority') {
                    const priorityOrder = { high: 3, medium: 2, low: 1 };
                    taskArray.sort((a, b) => priorityOrder[b.priority] - priorityOrder[a.priority]);
                } else if (currentSort === 'title') {
                    taskArray.sort((a, b) => a.title.localeCompare(b.title));
                }
            };
            
            sortTasks(pinnedTasks);
            sortTasks(unpinnedTasks);
            
            const fragment = document.createDocumentFragment();
            const totalTasks = pinnedTasks.length + unpinnedTasks.length;
            
            if (totalTasks === 0) {
                emptyState.style.display = 'block';
                tasksList.innerHTML = '';
            } else {
                emptyState.style.display = 'none';
                
                // Render pinned tasks
                for (let i = 0; i < pinnedTasks.length; i++) {
                    const taskElement = createTaskElement(pinnedTasks[i]);
                    fragment.appendChild(taskElement);
                }
                
                // Add separator if there are both pinned and unpinned tasks
                if (pinnedTasks.length > 0 && unpinnedTasks.length > 0) {
                    const separator = document.createElement('div');
                    separator.className = 'pinned-separator';
                    separator.innerHTML = `
                        <hr>
                        <div class="pinned-separator-text">Other Tasks</div>
                        <hr>
                    `;
                    fragment.appendChild(separator);
                }
                
                // Render unpinned tasks
                for (let i = 0; i < unpinnedTasks.length; i++) {
                    const taskElement = createTaskElement(unpinnedTasks[i]);
                    fragment.appendChild(taskElement);
                }
                
                tasksList.innerHTML = '';
                tasksList.appendChild(fragment);
            }
        }

        // Create task element
        function createTaskElement(task) {
            const taskCard = document.createElement('div');
            
            // Determine task status class
            let statusClass = '';
            if (task.dueDate) {
                const dueDate = new Date(task.dueDate);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);
                
                if (dueDate < today) {
                    statusClass = 'overdue';
                } else if (dueDate.getTime() === today.getTime() || dueDate.getTime() === tomorrow.getTime()) {
                    statusClass = 'due-soon';
                }
            }
            
            taskCard.className = `task-card ${task.status === 'completed' ? 'completed' : ''} ${task.priority} ${task.pinned ? 'pinned' : ''} ${statusClass}`;
            
            // Pin button
            const pinBtn = document.createElement('button');
            pinBtn.className = `pin-btn ${task.pinned ? 'pinned' : ''}`;
            pinBtn.innerHTML = task.pinned ? 'üìå' : 'üìç';
            pinBtn.title = task.pinned ? 'Unpin task' : 'Pin task';
            pinBtn.addEventListener('click', () => togglePinTask(task.id));
            
            // Task header with title and priority
            const taskHeader = document.createElement('div');
            taskHeader.className = 'task-header';
            
            const taskTitle = document.createElement('div');
            taskTitle.className = 'task-title';
            taskTitle.innerHTML = makeLinksClickable(task.title);
            taskTitle.title = task.title;
            taskTitle.addEventListener('click', (e) => {
                if (e.target.tagName !== 'A') {
                    makeEditable(taskTitle, (newContent) => {
                        updateTaskTitle(task.id, newContent);
                    });
                }
            });
            
            const taskPriority = document.createElement('div');
            taskPriority.className = `task-priority ${task.priority}`;
            taskPriority.textContent = task.priority.charAt(0).toUpperCase() + task.priority.slice(1);
            
            taskHeader.appendChild(taskTitle);
            taskHeader.appendChild(taskPriority);
            
            // Task meta information
            const taskMeta = document.createElement('div');
            taskMeta.className = 'task-meta';
            
            const taskDate = document.createElement('div');
            taskDate.className = 'task-date';
            taskDate.innerHTML = `<span>üìÖ</span> Created: ${formatDate(task.createdAt)}`;
            
            taskMeta.appendChild(taskDate);
            
            // Project badge
            if (task.project && task.project !== 'default') {
                const project = projects.find(p => p.id === task.project);
                if (project) {
                    const taskProject = document.createElement('div');
                    taskProject.className = 'task-project';
                    taskProject.style.backgroundColor = project.color + '20';
                    taskProject.style.color = project.color;
                    taskProject.style.border = `1px solid ${project.color}40`;
                    taskProject.innerHTML = `
                        <span class="tag-color-small" style="background-color: ${project.color}"></span>
                        ${project.name}
                    `;
                    taskMeta.appendChild(taskProject);
                }
            }
            
            // Due date
            if (task.dueDate) {
                const dueDate = new Date(task.dueDate);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                let dueDateClass = '';
                let dueDateText = '';
                
                if (dueDate < today) {
                    dueDateClass = 'overdue';
                    dueDateText = 'Overdue';
                } else if (dueDate.getTime() === today.getTime()) {
                    dueDateClass = 'due-soon';
                    dueDateText = 'Due today';
                } else if (dueDate.getTime() === today.getTime() + 86400000) {
                    dueDateClass = 'due-soon';
                    dueDateText = 'Due tomorrow';
                } else {
                    dueDateText = `Due: ${formatDate(task.dueDate)}`;
                }
                
                const taskDueDate = document.createElement('div');
                taskDueDate.className = `task-due-date ${dueDateClass}`;
                taskDueDate.innerHTML = `<span>‚è∞</span> ${dueDateText}`;
                taskMeta.appendChild(taskDueDate);
            }
            
            // Tags
            if (task.tags && task.tags.length > 0) {
                const taskTags = document.createElement('div');
                taskTags.className = 'task-tags';
                
                for (let i = 0; i < task.tags.length; i++) {
                    const tagName = task.tags[i];
                    const tag = tags.find(t => t.name === tagName);
                    if (tag) {
                        const taskTag = document.createElement('span');
                        taskTag.className = 'task-tag';
                        taskTag.style.backgroundColor = tag.color + '20';
                        taskTag.style.color = tag.color;
                        taskTag.style.border = `1px solid ${tag.color}40`;
                        taskTag.innerHTML = `
                            <span class="tag-color-small" style="background-color: ${tag.color}"></span>
                            ${tag.name}
                        `;
                        taskTags.appendChild(taskTag);
                    }
                }
                
                taskMeta.appendChild(taskTags);
            }
            
            // Subtasks section
            const subtasksSection = document.createElement('div');
            subtasksSection.className = 'subtasks-section';
            
            if (task.subtasks.length > 0) {
                const subtasksTitle = document.createElement('div');
                subtasksTitle.className = 'subtasks-title';
                
                let completedSubtasks = 0;
                for (let i = 0; i < task.subtasks.length; i++) {
                    if (task.subtasks[i].completed) completedSubtasks++;
                }
                
                subtasksTitle.innerHTML = `
                    <span>Subtasks (${completedSubtasks}/${task.subtasks.length})</span>
                `;
                
                const subtasksList = document.createElement('div');
                subtasksList.className = 'subtasks-list';
                
                for (let i = 0; i < task.subtasks.length; i++) {
                    const subtask = task.subtasks[i];
                    const subtaskItem = document.createElement('div');
                    subtaskItem.className = `subtask-item ${subtask.completed ? 'completed' : ''}`;
                    
                    const subtaskCheckbox = document.createElement('input');
                    subtaskCheckbox.type = 'checkbox';
                    subtaskCheckbox.className = 'subtask-checkbox';
                    subtaskCheckbox.checked = subtask.completed;
                    subtaskCheckbox.addEventListener('change', () => toggleSubtaskStatus(task.id, subtask.id));
                    
                    const subtaskTitle = document.createElement('span');
                    subtaskTitle.className = 'subtask-title';
                    subtaskTitle.innerHTML = makeLinksClickable(subtask.title);
                    subtaskTitle.title = subtask.title;
                    subtaskTitle.addEventListener('click', (e) => {
                        if (e.target.tagName !== 'A') {
                            makeEditable(subtaskTitle, (newContent) => {
                                updateSubtaskTitle(task.id, subtask.id, newContent);
                            });
                        }
                    });
                    
                    const deleteSubtaskBtn = document.createElement('button');
                    deleteSubtaskBtn.className = 'delete-subtask';
                    deleteSubtaskBtn.innerHTML = '‚úï';
                    deleteSubtaskBtn.title = 'Delete subtask';
                    deleteSubtaskBtn.addEventListener('click', () => deleteSubtask(task.id, subtask.id));
                    
                    subtaskItem.appendChild(subtaskCheckbox);
                    subtaskItem.appendChild(subtaskTitle);
                    subtaskItem.appendChild(deleteSubtaskBtn);
                    subtasksList.appendChild(subtaskItem);
                }
                
                subtasksSection.appendChild(subtasksTitle);
                subtasksSection.appendChild(subtasksList);
            }
            
            // Add subtask form
            const addSubtaskForm = document.createElement('div');
            addSubtaskForm.className = 'add-subtask-form';
            
            const addSubtaskInput = document.createElement('input');
            addSubtaskInput.type = 'text';
            addSubtaskInput.className = 'add-subtask-input';
            addSubtaskInput.placeholder = 'Add a subtask...';
            
            const addSubtaskBtn = document.createElement('button');
            addSubtaskBtn.className = 'add-subtask-btn';
            addSubtaskBtn.textContent = 'Add';
            addSubtaskBtn.addEventListener('click', () => {
                addSubtask(task.id, addSubtaskInput.value);
                addSubtaskInput.value = '';
            });
            
            addSubtaskInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    addSubtask(task.id, addSubtaskInput.value);
                    addSubtaskInput.value = '';
                }
            });
            
            addSubtaskForm.appendChild(addSubtaskInput);
            addSubtaskForm.appendChild(addSubtaskBtn);
            subtasksSection.appendChild(addSubtaskForm);

            // Deleted subtasks section
            if (task.deletedSubtasks && task.deletedSubtasks.length > 0) {
                const deletedSubtasksSection = document.createElement('div');
                deletedSubtasksSection.className = 'deleted-subtasks-section';
                
                const deletedSubtasksTitle = document.createElement('div');
                deletedSubtasksTitle.className = 'deleted-subtasks-title';
                deletedSubtasksTitle.innerHTML = `
                    <span>Deleted Subtasks (${task.deletedSubtasks.length})</span>
                `;
                
                const deletedSubtasksList = document.createElement('div');
                deletedSubtasksList.className = 'deleted-subtasks-list';
                
                for (let i = 0; i < task.deletedSubtasks.length; i++) {
                    const subtask = task.deletedSubtasks[i];
                    const deletedSubtaskItem = document.createElement('div');
                    deletedSubtaskItem.className = 'deleted-subtask-item';
                    
                    const deletedSubtaskTitle = document.createElement('span');
                    deletedSubtaskTitle.className = 'deleted-subtask-title';
                    deletedSubtaskTitle.innerHTML = makeLinksClickable(subtask.title);
                    deletedSubtaskTitle.title = subtask.title;
                    
                    const restoreSubtaskBtn = document.createElement('button');
                    restoreSubtaskBtn.className = 'restore-subtask';
                    restoreSubtaskBtn.innerHTML = '‚Ü∂';
                    restoreSubtaskBtn.title = 'Restore subtask';
                    restoreSubtaskBtn.addEventListener('click', () => restoreSubtask(task.id, subtask.id));
                    
                    deletedSubtaskItem.appendChild(deletedSubtaskTitle);
                    deletedSubtaskItem.appendChild(restoreSubtaskBtn);
                    deletedSubtasksList.appendChild(deletedSubtaskItem);
                }
                
                deletedSubtasksSection.appendChild(deletedSubtasksTitle);
                deletedSubtasksSection.appendChild(deletedSubtasksList);
                subtasksSection.appendChild(deletedSubtasksSection);
            }
            
            // Task actions
            const taskActions = document.createElement('div');
            taskActions.className = 'task-actions';
            
            const toggleBtn = document.createElement('button');
            toggleBtn.className = `task-action ${task.status === 'completed' ? 'warning' : 'success'}`;
            toggleBtn.innerHTML = task.status === 'completed' ? '‚Ü∂ Mark Pending' : '‚úì Mark Complete';
            toggleBtn.addEventListener('click', () => toggleTaskStatus(task.id));
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'task-action danger';
            deleteBtn.innerHTML = 'üóëÔ∏è Delete';
            deleteBtn.addEventListener('click', () => deleteTask(task.id));
            
            taskActions.appendChild(toggleBtn);
            taskActions.appendChild(deleteBtn);
            
            // Append all elements to the card
            taskCard.appendChild(pinBtn);
            taskCard.appendChild(taskHeader);
            taskCard.appendChild(taskMeta);
            taskCard.appendChild(subtasksSection);
            taskCard.appendChild(taskActions);
            
            return taskCard;
        }

        // Render trash with visibility control
        function renderTrash() {
            const fragment = document.createDocumentFragment();
            
            if (trash.length === 0) {
                emptyTrashState.style.display = 'block';
                trashSection.style.display = 'none';
                trashList.innerHTML = '';
            } else {
                emptyTrashState.style.display = 'none';
                trashSection.style.display = 'block';
                
                for (let i = 0; i < trash.length; i++) {
                    const task = trash[i];
                    const trashCard = document.createElement('div');
                    trashCard.className = 'trash-card';
                    
                    // Task header with title and priority
                    const taskHeader = document.createElement('div');
                    taskHeader.className = 'task-header';
                    
                    const taskTitle = document.createElement('div');
                    taskTitle.className = 'task-title';
                    taskTitle.innerHTML = makeLinksClickable(task.title);
                    taskTitle.title = task.title;
                    
                    const taskPriority = document.createElement('div');
                    taskPriority.className = `task-priority ${task.priority}`;
                    taskPriority.textContent = task.priority.charAt(0).toUpperCase() + task.priority.slice(1);
                    
                    taskHeader.appendChild(taskTitle);
                    taskHeader.appendChild(taskPriority);
                    
                    // Task dates
                    const taskDates = document.createElement('div');
                    taskDates.className = 'task-date';
                    taskDates.innerHTML = `
                        <div>Created: ${formatDate(task.createdAt)}</div>
                        <div>Deleted: ${formatDate(task.deletedAt)}</div>
                    `;
                    
                    // Trash actions
                    const trashActions = document.createElement('div');
                    trashActions.className = 'trash-actions-buttons';
                    
                    const restoreBtn = document.createElement('button');
                    restoreBtn.className = 'trash-action success';
                    restoreBtn.innerHTML = '‚Ü∂ Restore';
                    restoreBtn.addEventListener('click', () => restoreFromTrash(task.id));
                    
                    const deletePermanentlyBtn = document.createElement('button');
                    deletePermanentlyBtn.className = 'trash-action danger';
                    deletePermanentlyBtn.innerHTML = 'üóëÔ∏è Delete Permanently';
                    deletePermanentlyBtn.addEventListener('click', () => deleteFromTrash(task.id));
                    
                    trashActions.appendChild(restoreBtn);
                    trashActions.appendChild(deletePermanentlyBtn);
                    
                    // Append all elements to the card
                    trashCard.appendChild(taskHeader);
                    trashCard.appendChild(taskDates);
                    trashCard.appendChild(trashActions);
                    
                    fragment.appendChild(trashCard);
                }
                
                trashList.innerHTML = '';
                trashList.appendChild(fragment);
            }
        }

        // Restore task from trash
        async function restoreFromTrash(taskId) {
            const taskIndex = trash.findIndex(t => t.id === taskId);
            if (taskIndex !== -1) {
                const [restoredTask] = trash.splice(taskIndex, 1);
                delete restoredTask.deletedAt;
                tasks.push(restoredTask);
                await saveData();
                renderTasks();
                renderTrash();
                showToast('Task restored from trash', 'success');
            }
        }

        // Delete task permanently from trash
        async function deleteFromTrash(taskId) {
            const taskIndex = trash.findIndex(t => t.id === taskId);
            if (taskIndex !== -1) {
                trash.splice(taskIndex, 1);
                await saveData();
                renderTrash();
                showToast('Task permanently deleted', 'success');
            }
        }

        // Restore all tasks from trash
        async function restoreAllFromTrash() {
            const trashLength = trash.length;
            if (trashLength === 0) {
                showToast('Trash is already empty', 'info');
                return;
            }
            
            for (let i = 0; i < trashLength; i++) {
                delete trash[i].deletedAt;
                tasks.push(trash[i]);
            }
            
            trash.length = 0;
            await saveData();
            renderTasks();
            renderTrash();
            showToast('All tasks restored from trash', 'success');
        }

        // Empty trash
        async function emptyTrash() {
            const trashLength = trash.length;
            if (trashLength === 0) {
                showToast('Trash is already empty', 'info');
                return;
            }
            
            if (confirm('Are you sure you want to permanently delete all tasks in trash? This action cannot be undone.')) {
                trash.length = 0;
                await saveData();
                renderTrash();
                showToast('Trash emptied', 'success');
            }
        }

        // Generate Text report
        function generateTextReport() {
            let reportContent = `ALQAAB Task Manager Report\n`;
            reportContent += `Generated on: ${new Date().toLocaleDateString()}\n\n`;
            
            const allTasks = tasks;
            let completedTasks = 0;
            let pendingTasks = 0;
            let pinnedTasks = 0;
            let overdueTasks = 0;
            
            // Group tasks by project
            const tasksByProject = {};
            
            for (let i = 0; i < allTasks.length; i++) {
                const task = allTasks[i];
                const projectName = getProjectName(task.project);
                
                if (!tasksByProject[projectName]) {
                    tasksByProject[projectName] = [];
                }
                tasksByProject[projectName].push(task);
                
                if (task.status === 'completed') {
                    completedTasks++;
                } else {
                    pendingTasks++;
                }
                if (task.pinned) {
                    pinnedTasks++;
                }
                if (task.dueDate && new Date(task.dueDate) < new Date() && task.status !== 'completed') {
                    overdueTasks++;
                }
            }
            
            reportContent += `SUMMARY\n`;
            reportContent += `Total Tasks: ${allTasks.length}\n`;
            reportContent += `Projects: ${Object.keys(tasksByProject).length}\n`;
            reportContent += `Pinned: ${pinnedTasks}\n`;
            reportContent += `Completed: ${completedTasks}\n`;
            reportContent += `Pending: ${pendingTasks}\n`;
            reportContent += `Overdue: ${overdueTasks}\n\n`;
            
            reportContent += `TASKS BY PROJECT\n`;
            reportContent += `====================\n\n`;
            
            // Sort projects alphabetically
            const sortedProjects = Object.keys(tasksByProject).sort();
            
            for (let p = 0; p < sortedProjects.length; p++) {
                const projectName = sortedProjects[p];
                const projectTasks = tasksByProject[projectName];
                
                reportContent += `PROJECT: ${projectName.toUpperCase()}\n`;
                reportContent += `${'-'.repeat(50)}\n\n`;
                
                // Separate pinned and unpinned tasks within the project
                const pinnedProjectTasks = projectTasks.filter(t => t.pinned);
                const unpinnedProjectTasks = projectTasks.filter(t => !t.pinned);
                
                // Pinned tasks in this project
                if (pinnedProjectTasks.length > 0) {
                    reportContent += `PINNED TASKS\n`;
                    for (let i = 0; i < pinnedProjectTasks.length; i++) {
                        const task = pinnedProjectTasks[i];
                        reportContent += `${i + 1}. ${task.title} [${task.priority.toUpperCase()}] [PINNED]\n`;
                        reportContent += `   Status: ${task.status === 'completed' ? 'Completed' : 'Pending'}\n`;
                        reportContent += `   Created: ${formatDate(task.createdAt)}\n`;
                        if (task.dueDate) {
                            reportContent += `   Due: ${formatDate(task.dueDate)}\n`;
                        }
                        if (task.tags.length > 0) {
                            reportContent += `   Tags: ${task.tags.join(', ')}\n`;
                        }
                        
                        if (task.subtasks.length > 0) {
                            reportContent += `   Subtasks:\n`;
                            for (let j = 0; j < task.subtasks.length; j++) {
                                const subtask = task.subtasks[j];
                                reportContent += `     - ${subtask.title} [${subtask.completed ? 'Completed' : 'Pending'}]\n`;
                            }
                        }
                        reportContent += `\n`;
                    }
                }
                
                // Other tasks in this project
                if (unpinnedProjectTasks.length > 0) {
                    reportContent += `OTHER TASKS\n`;
                    for (let i = 0; i < unpinnedProjectTasks.length; i++) {
                        const task = unpinnedProjectTasks[i];
                        reportContent += `${i + 1}. ${task.title} [${task.priority.toUpperCase()}]\n`;
                        reportContent += `   Status: ${task.status === 'completed' ? 'Completed' : 'Pending'}\n`;
                        reportContent += `   Created: ${formatDate(task.createdAt)}\n`;
                        if (task.dueDate) {
                            reportContent += `   Due: ${formatDate(task.dueDate)}\n`;
                        }
                        if (task.tags.length > 0) {
                            reportContent += `   Tags: ${task.tags.join(', ')}\n`;
                        }
                        
                        if (task.subtasks.length > 0) {
                            reportContent += `   Subtasks:\n`;
                            for (let j = 0; j < task.subtasks.length; j++) {
                                const subtask = task.subtasks[j];
                                reportContent += `     - ${subtask.title} [${subtask.completed ? 'Completed' : 'Pending'}]\n`;
                            }
                        }
                        reportContent += `\n`;
                    }
                }
                
                reportContent += `\n`;
            }
            
            // Create and download the text file
            const blob = new Blob([reportContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `alqaab-todo-report-${new Date().toISOString().split('T')[0]}.txt`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showToast('Text report downloaded successfully', 'success');
        }
        
        // Helper function to get project name by ID
        function getProjectName(projectId) {
            const project = projects.find(p => p.id === projectId);
            return project ? project.name : 'Uncategorized';
        }

        // Export data as JSON
        function exportData() {
            const data = {
                tasks: tasks,
                trash: trash,
                tags: tags,
                projects: projects,
                exportDate: new Date().toISOString(),
                version: 'ALQAAB Task Manager v2.1'
            };
            
            const dataStr = JSON.stringify(data, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `alqaab-todo-backup-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showToast('Data exported successfully', 'success');
        }

        // Import data from JSON file
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                setTimeout(async () => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        
                        if (confirm('This will replace all current data. Are you sure?')) {
                            tasks = importedData.tasks || [];
                            trash = importedData.trash || [];
                            tags = importedData.tags || tags;
                            projects = importedData.projects || projects;
                            
                            for (let i = 0; i < tasks.length; i++) {
                                if (!tasks[i].deletedSubtasks) {
                                    tasks[i].deletedSubtasks = [];
                                }
                                if (!tasks[i].tags) {
                                    tasks[i].tags = [];
                                }
                                if (!tasks[i].project) {
                                    tasks[i].project = 'default';
                                }
                                if (tasks[i].pinned === undefined) {
                                    tasks[i].pinned = false;
                                }
                            }
                            
                            // Ensure default project exists
                            const defaultProjectExists = projects.find(p => p.id === 'default');
                            if (!defaultProjectExists) {
                                projects.unshift({ id: 'default', name: 'All Tasks', color: '#4361ee' });
                            }
                            
                            await saveData();
                            renderProjects();
                            renderTagsFilter();
                            populateProjectDropdown();
                            renderTasks();
                            renderTrash();
                            showToast('Data imported successfully', 'success');
                        }
                    } catch (error) {
                        showToast('Error importing data: Invalid file format', 'error');
                    }
                    
                    event.target.value = '';
                }, 0);
            };
            
            reader.readAsText(file);
        }

        // Clear all data
        async function clearData() {
            if (confirm('Are you sure you want to clear all data? This action cannot be undone.')) {
                tasks.length = 0;
                trash.length = 0;
                // Keep default projects
                projects = [
                    { id: 'default', name: 'All Tasks', color: '#4361ee' },
                    { id: 'personal', name: 'Personal', color: '#4cc9f0' },
                    { id: 'work', name: 'Work', color: '#f8961e' }
                ];
                // Keep default tags
                tags = [
                    { name: 'work', color: '#4361ee' },
                    { name: 'personal', color: '#4cc9f0' },
                    { name: 'home', color: '#f8961e' },
                    { name: 'smit', color: '#f72585' },
                    { name: 'learning', color: '#3f37c9' },
                    { name: 'urgent', color: '#dc2626' }
                ];
                currentProject = 'default';
                currentTagFilter = null;
                await saveData();
                renderProjects();
                renderTagsFilter();
                populateProjectDropdown();
                renderTasks();
                renderTrash();
                showToast('All data cleared', 'success');
            }
        }

        // Show toast notification
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            
            const toastContainer = document.getElementById('toastContainer');
            toastContainer.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // Utility functions
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        // Simple sample tasks for initial setup
        function getSampleTasks() {
            const now = new Date();
            
            return [
                {
                    id: generateId(),
                    title: 'Welcome to ALQAAB Task Manager',
                    priority: 'medium',
                    project: 'default',
                    status: 'pending',
                    createdAt: now.toISOString(),
                    dueDate: null,
                    tags: ['learning'],
                    subtasks: [],
                    deletedSubtasks: [],
                    pinned: true
                },
                {
                    id: generateId(),
                    title: 'Add your first task above',
                    priority: 'low',
                    project: 'default',
                    status: 'pending',
                    createdAt: now.toISOString(),
                    dueDate: null,
                    tags: ['personal'],
                    subtasks: [],
                    deletedSubtasks: [],
                    pinned: false
                }
            ];
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
